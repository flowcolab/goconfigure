package goconfigureimport (	"encoding/json"	"fmt"	"reflect"	"strings")type ConfigProperties map[string]anytype ConfigPropertiesVisitor func(indices []string, memberValue any) (proceed bool)func TryConvertToConfigProperties(val any) (ConfigProperties, bool) {	if convVal, convValOk := val.(map[string]any); convValOk {		return convVal, true	} else if convVal, convValOk = val.(ConfigProperties); convValOk {		return convVal, true	} else {		return nil, false	}}func (props ConfigProperties) HasProperties() bool {	return len(props) > 0}func (props ConfigProperties) String() string {	writer := strings.Builder{}	encoder := json.NewEncoder(&writer)	encoder.SetIndent("", "  ")	if err := encoder.Encode(props); err == nil {		return writer.String()	} else {		return "error creating properties string"	}}func (props ConfigProperties) IsSameAs(other ConfigProperties) (ok bool) {	ok = true	if &props == &other {		return	}	props.Visit(func(indices []string, propValue any) bool {		if otherPropValue, otherOk := other.FindByIndex(indices); otherOk {			if subProps, subPropsOk := TryConvertToConfigProperties(propValue); subPropsOk {				if otherSubProps, otherSubPropsOk := TryConvertToConfigProperties(otherPropValue); otherSubPropsOk && len(subProps) == len(otherSubProps) {					return true				}			} else {				return reflect.DeepEqual(propValue, otherPropValue)			}		}		ok = false		return false	})	return}func (props ConfigProperties) Difference(other ConfigProperties) ConfigProperties {	diffProps := ConfigProperties{}	if &props == &other {		return diffProps	}	props.Visit(func(indices []string, propValue any) bool {		// if current index value is not found on other properties then add it to the difference		if otherPropValue, otherOk := other.FindByIndex(indices); !otherOk || !reflect.DeepEqual(otherPropValue, propValue) {			if err := diffProps.SetIndex(indices, propValue); err != nil {				panic(fmt.Sprintf("error setting difference at index '%s' to value '%v': %s",					strings.Join(indices, "."), propValue, err.Error()))			}		}		return true	})	return diffProps}func (props ConfigProperties) SetIndex(indices []string, value any) error {	var currentValue any = props	var currentIndex = make([]string, len(indices))	for index, propIndex := range indices {		currentIndex = append(currentIndex, propIndex)		// if last index then set the value on map otherwise navigate to the next map		if index < len(indices)-1 {			if props, ok := TryConvertToConfigProperties(currentValue); ok {				props[propIndex] = ConfigProperties{}				currentValue = props[propIndex]			} else {				return fmt.Errorf("could not set properties at index '%s' because index is not a map",					strings.Join(indices, "."))			}		} else {			if props, ok := TryConvertToConfigProperties(currentValue); ok {				props[propIndex] = value			} else {				return fmt.Errorf("could not set properties at index '%s' because index is not a map",					strings.Join(indices[:len(indices)-1], "."))			}		}	}	return nil}func (props ConfigProperties) Visit(visitor ConfigPropertiesVisitor) {	visitNode([]string{}, props, true, visitor)}func (props ConfigProperties) VisitIndex(indices []string, visitor ConfigPropertiesVisitor) {	if value, ok := props.FindByIndex(indices); ok {		visitNode(indices, value, true, visitor)	}}func visitNode(currentIndices []string, value any, visitOnlyValues bool, visitor ConfigPropertiesVisitor) bool {	if value == nil {		return false	}	if valueAsMap, ok := value.(ConfigProperties); ok {		for propName, propValue := range valueAsMap {			if !visitOnlyValues {				if proceed := visitor(currentIndices, propValue); !proceed {					return false				}			}			if proceed := visitNode(append(currentIndices, propName), propValue, visitOnlyValues, visitor); !proceed {				return false			}		}		return true	}	return visitor(currentIndices, value)}func (props ConfigProperties) SubProperties(indices []string) (subProps ConfigProperties, ok bool) {	if currentValue, ok := props.FindByIndex(indices); ok {		if currentProps, ok := currentValue.(ConfigProperties); ok {			return currentProps, true		}	}	return nil, false}func (props ConfigProperties) FindByIndex(indices []string) (any, bool) {	var currentValue any = props	for _, propIndex := range indices {		if currentValue == nil {			return nil, false		}		if valAsProps, valAsPropsOk := TryConvertToConfigProperties(currentValue); valAsPropsOk {			currentValue = valAsProps[propIndex]		} else {			return nil, false		}	}	return currentValue, true}